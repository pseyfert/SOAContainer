### Navigation: [<< (previous)](internals-5.2.md), [(up)](tutorial.md), [(next) >>](tutorial.md)

# ```SOA::Field``` internals

```SOA::Field``` is a newer implementation of fields which became necessary
because the overly loose coupling between a field and its accessor methods
in the skin became a burden. To improve the situation, a new approach to
implementing fields was designed such that a field and its accessors
(getters and setters) can be kept together. This results in a number of
advantages:

- skins that need no other functionality besides the accessor methods become
  much easier to implement (see next section)
- fields can be reused in multiple skins, without the need to duplicate
  code for the accessors of fields
- it is much easier to implement views, because a basic skin can be
  generated by the compiler

To reap these benefits, a field becomes a much more complicated beast. It
derives from a common base class:

```C++
template <typename T, class FIELD>
class FieldBase {
    public:
        using self_type = FIELD; // the field tag itself
        using wrap_tag = struct {}; // tell Container/View that we wrap a type
        using type = T; // type we wrap
    protected:
        template <class SKIN>
        struct AccessorBase { // helper to "rebind" field to different skins
            // retrieve reference to the field
            type& _get()
            {return static_cast<SKIN&>(*this).template get<FIELD>();}
            // retrieve const reference to the field
            const type& _get() const
            {return static_cast<const SKIN&>(*this).template get<FIELD>();}
        };
};
```

The ```FieldBase class``` thus serves a twofold purpose: It has all
the usual type wrapping machinery which we already know. In addition, it
holds a little helper struct that helps with the access to the data of the
field. (It essentially does the equivalent of
```this->template get<field>()``` in the old design).

This obviously needs to go together with the actual definition of a field.
Let's define a float field called x, with setters and getters of the same
name:

```C++
struct x : SOA::impl::FieldBase<float, x> {
    // x is a FieldBase that describes a float, and has x as a template
    // parameter to FieldBase, so that FieldBase knows what kind of field
    // it's being used in

    // moreover, we need a little helper that pushes the required accessors
    // into the skin
    template <class SKIN> struct accessors : AccessorBase<SKIN>
    {
        // the "interface" that the field provides is below
        FieldBase::type& x()
        { return this->_get(); } \
        const FieldBase::type& x() const
        { return this->_get(); }
    };
};
```

A couple of remarks seem to be in order:
- the coupling between these new-style fields and skins (see next section)
  is quite tight, so read on...
- it's important that Fields and its base and helper classes are empty (no
  data members or virtual functions), since the empty base class
  optimisation must work for things to be usable
- the skin (defined later) will derive from the ```accessors``` helper
- the code above is the pedestrian version, and still requires quite a lot
  of boilerplate code; for that reason, there are a couple of macros like
  ```SOAFIELD_TRIVIAL``` , ```SOAFIELD``` , and ```SOAFIELD_ACCESSORS```,
  which should take care of all the extra typing.

With the macros mentioned above, all the code from this section can be
condensed into this:

```C++
SOAFIELD_TRIVIAL(x, x, float); // field called x, accessor called x(), float
```

Read on to see how the story with the fields turns out when the skins arrive
on stage...

### Navigation: [<< (previous)](internals-5.2.md), [(up)](tutorial.md), [(next) >>](tutorial.md)